
** 함수 
1.arguments
=>자바스크립트의 함수에는 arguments라는 지역변수가 숨겨져 있습니다. 
=>함수를 호출할 때 대입한 매개변수들의 배열 
=>함수를 선언할 때 매개변수 이름을 ()안에 만들지만 자바스크립트에서는 ()안에 매개변수를 선언
하지 않아도 arguments를 이용해서 매개변수를 사용할 수 있습니다. 
=> 자바스크립트의 많은 Maker Function들이 선언되는 부분만 보면 function 함수이름()로 만들어져 
있는데 매개변수를 대입하는 형태로 사용합니다. 
함수의 내용 부분에서 매개변수를 arguments를 이용해서 접근하기 때문입니다. 
=>이런 부분들 때문에 자바스크립트에서는 주석을 만들어주지 않으면 함수의 기능을 파악하기가 
어려울 수 있습니다. 
=>자바스크립트의 Maker Function을 공부를 할 때는 사용 예만 확인하지 말고 도큐먼트를 정확하게 
확인해 봐야 합니다. 

2.return 
=>함수의 수행을 종료하고 함수를 호출한 곳으로 제어권을 이동시키는 제어문 
=>자바스크립트 함수는 return type을 별도로 표시하지 않고 함수 내에서 return 또는 return데이터
의 형태로 리턴을 합니다. 

3.자바스크립트에서 함수는 일급객체 
=>자바스크립트에서 함수도 하나의 자료형 
=>함수의 내용을 변수에 저장할 수 있고 함수를 return 할 수도 있습니다. 
=>함수를 함수의 매개변수로 대입도 가능: 이 기능을 이용해서 이벤트 처리를 합니다. 

4. 자바스크립트에서는 함수안에 함수를 만들 수 있습니다.

5. 자바스크립트에서는 함수를 리턴해서 외부에서 함수 내부의 데이터를 조작할 수 있도록 
할 수 있습니다. 이 기능을 closure(클로져)라고 합니다. 

6.callback function 
=>어떤 이벤트가 발생했을 때 수행되는 함수 

7. polymorphism(다형성) 
=>하나의 코드가 상황에 따라 다른 메소드를 호출하는 것 
=>객체지향 언어에서는 상속과 오버라이딩을 이용해서 구현 

8.클로저를 만드는 이유 
=> 함수안에 만들어진 변수는 함수 안에서만 사용이 가능 
=>함수안에 만들어진 변수를 외부에서 수정할 수 없습니다. 
=> 이때 closure를 이용하면 가능 
내부함수는 자신이 포함된 외부함수의 변수를 사용할 수 있습니다. 
외부함수의 변수를 조작하는 내부함수를 만들고 이 함수를 리턴하면 함수 바깥쪽에서
리턴받은 함수를 호출하는 형태로 조작이 가능합니다. 

9.Maker Function(내장함수) 
=>브라우저 제조사에서 제공해주는 함수
=>window객체에 내장된 함수인데 window객체는 이름을 생략하고 사용할 수 있어서 전역함수
처럼 사용합니다. 

1)alert(msg)
=> 대화상자에 메시지를 출력해주는 함수 

2)confirm(msg)
=>대화상자에 메시지를 출력해주고 확인과 취소 버튼을 출력 
확인을 누르면 true 취소를 누르면 false를 리턴 

3)prompt(msg, default value) 
=>한줄의 텍스트를 입력받는 대화상자를 출력 
=>첫번째 매개변수는 메시지이고 두번째 매개변수는 텍스트 상자에 입력된 기본값 
=>확인과 취소버튼을 만들어 주는데 확인을 선택하면 입력한 텍스트가 리턴되고 취소를 선택하면 
null이 리턴됩니다. 

4)eval(name) 
=>name에 해당하는 객체를 생성해서 리턴해주는 함수 
=> form에서 구성요소에 접근하기 위한 목적으로 많이 사용 
=>최근에는 document.getElementById를 권장 

5)인코딩 & 디코딩 함수 
escape(문자열): 일부 특수 문자를 제외한 모든 문자를 인코딩해서 리턴해주는 함수 
encodeURI(문자열): 인터넷주소에 사용되는 일부 특수문자는 변환하지 않고 인코딩에서 리턴해주는 
함수 
encodeURIComponent(문자열): 알파벳과 숫자를 제외한 모든 문자를 인코딩해서 리턴해주는 함수 

반대로 디코딩해주는 함수는 unescape, decodeURI, decodeURIComponent 

6) 인코딩 할 때 주의할 점
=>URL에 한글이 있으면 반드시 인코딩을 해야하는데 파라미터만 인코딩합니다. 
프로토콜://서버경로:포트번호/파일경로?파라미터이름=파라미터값,... 
파라미터 이외의부분도 인코딩을 해버리면 : 이나 /도 인코딩되서 이상한 결과가 만들어 질 수 있습니다. 
=>스마트 폰애플리케이션에서 작업을 할 때는 반드시 실제 디바이스에서 테스트를 해봐야 합니다. 

7)isNaN
=>데이터가 숫자인지 판별해주는 함수 

8)isFinite
=>유한한 수인지 판별해주는 함수 

9)parseInt 
=>문자열을 정수로 변환해주는 함수 
=>변환할 수 있는 부분까지만 변환 
=>매개변수는 첫번째는 변환할 문자열이고 두번째는 진법으로 숫자로 입력 

10)parseFloat
=>문자열을 실수로 변환해주는 함수 
=>변환할 수 있는 부분까지만 변환해주고 parseDouble도 존재 

** Object(객체) 
=>객체: 데이터를 저장하고 사용할 수 있는 속성(변수)과 기능을 수행하는 메소드(함수)를 소유한 것 
1.종류 
1)사용자 정의 객체: 개발자가 생성한 객체 

2)내장 객체
- 일반객체: 일반적인 목적에 사용되는 객체로 Math, String, Array 객체 
- BOM(browser Object Model) : 브라우저와 관련된 객체 
- DOM(Document Object Model) : body안에 만드는 태그들을 위한 객체 

2. 사용자 정의 객체 - Java의 Map과 유사
1)생성
{속성:데이터, 속성:데이터...}

2)객체를 이용한 속성 접근 
객체이름.속성 또는 객체이름[속성] 

3)메소드 추가 가능 

4)for-in 
=>for ~ in 구문에 객체를 대입하면 객체의 속성이 임시변수에 문자열로 순서대로 대입됩니다. 

5)이름 in 객체 
=>이름에 해당하는 속성이 있으면 true 없으면 false를 리턴 

6)with
with(객체명){
       이 안에서는 객체의 속성을 사용할 때 객체 이름을 생략하고 사용이 가능합니다. 
}
=> 이 구문을 이용하면 코드를 짧게 만들고 코딩이 편리하기는 하지만 가독성이 떨어집니다. 
객체이름을 생략하게 되면 이 속성이 전역인지 window객체의 것인지 아니면 with에 있는 객체의 
것인지 혼란이옵니다. 
개발을 할 때 window객체의 속성을 사용할 때도 window.의 형태로 사용하는 것을 권장 

7)객체 속성 추가 및 삭제 
=>java의 map과 유사하게 동작 
=>없는 속성이름을 사용하고 데이터를 대입하면 추가 
=>존재하는 속성이름을 사용하고 데이터를 대입하면 갱신
=>delete(객체이름.속성): 속성을 호출하면 undefined
 
8)생성자 (Constructor) 
=>객체를 생성하기 위해 호출하는 특별한 형태의 메소드 
function 생성자이름(매개변수 나열){
    내용작성 
}
=> 생성자함수에서 지역변수가 아니라 멤버속성을 만들고자 하면 this.을 붙여서 만들면 됩니다. 
this.이 없으면 지역변수가 됩니다. 
=>생성자를 호출할 때는 new라는 연산자를 사용해야하고 호출결과는 생성한 객체의 참조를 
리턴합니다. 

3.일반 내장 객체 
=>http://www.w3schools.com/jsref/default.asp파일에서 속성과 메소드 확인 가능 
devdocs.io/javascript에서도 확인 가능 
=>내장객체는 new를 이용해서 생성자를 호출해서 객체를 만들어 사용하기도 하지만 Math의 경우는 
모든 메소드가 math를 이용해서 호출하기 때문에 별도의 객체를 생성하지 않고 사용 

1)Object 객체 
=>최상위 객체
=>자바스크립트의 모든 객체는 Object를 상속 
=>객체생성방법 
{ }
new Object() 

=>메소드 
String toString(): 객체를 문자열로 표현하기 위한 메소드 
                           출력하는 메소드에 객체이름만 대입한 경우 자동으로 호출되서 결과를 출력 

=> prototype.속성 = 데이터 
의 형태로 호출하면 이후 모든 객체에 속성이 추가됩니다. 

2)Number 객체 - 숫자를 저장하기 위한 객체 
=> number(숫자 또는 숫자로 만들어진 문자열) 를 이용해서 생성하기도 하고 숫자를 직접 대입해서
생성하기도 함 

var obj = 23; 
var obj = number(숫자 또는 문자열로 된 숫자); 

3)String 
=>문자열을 저장하기 위한 클래스 
=> 문자열 상수를 직접 대입해서 만들 수 있고 new String("문자열")을 이용해서 객체생성가능 
=>length라는 속성이 문자열의 길이를 저장 
=>String은 한 번 저장되면 자신의 내용을 수정할 수 없습니다. 
String에서 문자열을 수정하는 메소드는 복사해서 작업을 수행한 후 결과를 리턴합니다. 
=>charAt(인덱스), charCodeAt(인덱스), indexOf(문자열), lastIndexOf(문자열), split(문자열),
subString(), substr(), toLowerCase(), toUpperCase(), trim() 

charCodeAt, indexOf와 lastIndexOf는 정수로 리턴 
split은 문자열 배열로 리턴 
 
4)Math 
=>모든 속성과 메소드가 정적 멤버라거 객체를 생성해서 호출할 필요가 없습니다. 
=>PI속성: 파이 값 
=>메소드 
ceil(), round(), floor(): 올림, 반올림, 버림함수 
random(): 0.0~1.0사이의 랜덤한 실수 

5)Date 
=>날짜와 시간 관련 객체 
=>생성 
new Date():현재 날짜 및 시간 
new Date(년, 월, 일, 시, 분, 초, 1/1000초)
new Date(epoch time): epoch time은 1970년 1월 1일 자정부터 지나온 시간으로 1/1000초 단위 

=>메소드 
각각의 값을 가져오는 get?()와 설정을 위한 set?()메소드가 존재 
문자열로 리턴해주는 toGMTString(), toLocaleString(), toString() 메소드가 존재 

6)Array 
=>배열 객체 
=>베열은 List의 개념 - 생성한 후 추가와 삭제가 가능 
=>생성 
[초기값 나열] 
new Array(값을 나열) 
new Array(정수 1개): 정수만큼의 공간을 확보한 배열을 생성 

=>배열의 요소접근은 배열이름[인덱스]를 이용 

=>배열의 데이터 개수는 length속성 

=>for~in을 이용하면 배열의 인덱스를 순서대로 임시변수에 대입 

# Double Linked List - 최근 언어의 배열 
=>데이터와 2개의 데이터 참조를 저장할 수 있는 인덱스로 구성 
    [prev | data | next ] 구조로 이루어짐 

=>concat(배열): 배열을 이어붙임 
=>join(ddelimiter - 구분자): 데이터 각각에 구분자를 추가해서 하나의 문자열로 만들어서 문자열을 리턴 
=>reverse(): 데이터의 순서를 반대로 배치 

=>push(데이터): 데이터를 마지막에 추가 
=>pop():마지막 데이터를 제거하고 리턴 

=>shift():첫번째 데이터를 제거하고 리턴 
=>unshift(데이터): 첫번째 위체에 데이터를 추가 

remove(인덱스): 인덱스 번째에 해당하는 데이터를 제거 

=>indexOf(데이터, 찾는시작위치): 데이터를 시작위치부터 찾아서 찾으면 그 위치를 못찾으면 음수를 리턴 

=>lastIndexOf(데이터): 데이터를 뒤에서부터 찾아서 찾으면 그 위치를 못찾으면 음수를 리턴 

=>데이터의 정렬을 수행해주는 함수: sort() 
숫자나 문자열 데이터의 경우 오름차순 정렬을 해주는 함수 
숫자 데이터의 경우의 문자열로 간주하고 정렬 
원하는 형태로 정렬을 하고자 하면 sort함수에 비교하는 함수를 대입해 주어야 합니다.
이때 이 함수는 매개변수가 2개이고 정수를 리턴하는 함수이어야 합니다. 
매개변수 2개는 배열의 데이터를 정렬하기 위해서 비교하는 데이터 2개 입니다. 
첫번째 매개변수가 두번째 매개변수보다 크다면 양수를 리턴하고 같다면 0을 작다면 음수를 리턴하도록
만들면 오름차순 정렬을 합니다. 
정수의 부호를 반대로 리턴하면 내림차순 정렬이 됩니다. 

=>배열에 추가된 함수 

forEach() : 배열의 모든 요소에 동일한 함수를 실행하고자 할 때 사용  

map(): 배열의 모든 요소에 함수를 적용해서 리턴값들로 새로운 배열을 만들어 주는 것 

filter() : 배열의 모든 요소에 함수를 적용해서 true를 리턴하는 데이터만 가지고 새로운 배열을 만들어 
주는 것 

매개변수로 대입되는 함수는 모양이  function(element, index, array){}구조 입니다. 
첫번째 매개변수는 배열의 각 요소이고 두번째 매개변수는 인덱스이고 세번째 매개변수는 배열입니다.
 
7)JSON객체 
=>JSON.parse(문자열): 문자열이 JSON형식으로 만들어져 있다면 자바스크립트 데이터로 변환해 줍니다.

=>JSON.stringify(자바스크립트 데이터):JSON문자열로 변환해서 리턴합니다. 

=>XML파싱보다 JSON파싱이 쉽기 때문에 ptyhon이나 javascript를 이용하는 클라이언트 프로그램
을 사용하는 경우에는 서버에서 데이터를 넘겨줄 때 JSON이면 편리하게 사용이 가능합니다. 

**BOM(Browser Object Model)
=>브라우저와 관련된 객체의 집합 
=>window, location, navigator, history, screen, document 객체 등 
=>협의의 BOM을 애기할 때는 document객체는 DOM(Document Object Model)로 분리 

1.window객체 
=>웹 브라우저에 해당하는 객체 
=>자신이 소유한 속성이나 메소드를 사용할 때 window.을 생략해도 됨 
1)location속성 
=> 현재 URL을 저장하고 있는 속성 
=>location에 다른 URL을 대입하면 URL로 이동 

2)opener 속성 
=>현재 윈도우를 연 윈도우 : 팝업창의 경우 팝업창을 연 윈도우

3)self속성 
=>현재 윈도우 
=>팝업창을 이용할 때 팝업창의 내용을 자신을 연 윈도우에게 전달할 때opener.속성 = self.속성

4)close(): 닫기 

5)open():팝업창을 출력하는 메소드 
open(출력할 URL, 윈도우 이름, 옵션)

6)타이머 관련 함수 
setTimeout(수행할 함수, 시간): 시간 후에 함수를 1번 수행 
setInterval(수행할 함수, 시간): 시간 마다 함수를 수행 

2개의 함수의 결과를 변수에 저장해두고 clearTimeout(타이머변수)나 clearInterval(타이머변수)을 
호출하면 타이머가 종료 

7)브라우저의 형태에 관련된 메소드 
moveBy(x,y):현재 위치에서 x와 y만큼 이동 
resizeBy(x,y)
scrollBy(x,y) 

moveTo(x,y) : x와 y좌표로 이동 
resizeTo(x,y)
scrollTo(x,y)

focus() :포커스 
blur(): 포커스를 해제 
close(): 닫기

=>최근에는 하나의 화면에 데이터를 전부 표현할 수 없는 경우에 페이징 대신에 하단에서 스크롤을 해서 
데이터를 업데이트 하도록 해주는 경우가 있는데 이 때 데이터를 업데이트하고 스크롤을 옮겨 줍니다. 

2.screen객체 
=>화면표시에 대한 정보를 제공하는 객체 
availHeight, availWidth : 표시 가능한 웹 브라우저의 높이와 너비  
height, width : 웹 브라우저의 스크린 너비와 높이 
=> 읽기 전용 속성 

3.location 객체 
=>URL정보를 저장하는 객체 
프로토콜://도메인 또는 IP주소: 포트번호/요청경로?파라미터이름=값&파라미터이름=값...
1)속성 
host : 서버의 주소와 포트번호 
hostname : 도메인 이름 또는 ip주소 
pathname : 요청 경로 
port : 포트번호 
protocol : 프로토콜 
search : 쿼리 스트링(파라미터)

href : URL전체를 저장하고 있는데 다른 URL을 대입하면 그 URL로 이동 

2)메소드 
replace(URL):URL로 이동 
reload(): 새로 고침 
forward(): 앞으로 
back(): 뒤로 
go(인덱스): 현재 URL에서 인덱스만큼 이동 
음수이면 뒤로 양수를 사용하면 앞으로의 기능 

3)자바스크립트로 특정 URL로 이동 
window.location = "이동할 URL";

location.href = "이동할 URL"; 

location.replace("이동할 URL"); 
 










































 
